<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Implementing the IGrid Interface | Gamelogic Grids </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Implementing the IGrid Interface | Gamelogic Grids ">
      
      
      <link rel="icon" href="../images/gamelogic_favicon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://bitbucket.org/gamelogic/gridsunity/src/master/Documentation/content/ImplementingIGrid.md#lines-1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

      <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-68729P67EH"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-68729P67EH');
      </script>
  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/gamelogic_icon.png" alt="Gamelogic Grids">
            Gamelogic Grids
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="implementing-the-igrid-interface">Implementing the <code>IGrid</code> Interface</h1>

<p>This article explains how to implement the <a class="xref" href="../api/Gamelogic.Grids2.IGrid-2.html">IGrid&lt;TPoint, TCell&gt;</a> interface to create custom grids.</p>
<p>Suppose we want to define our own grid, but still want to use many of the grid functions (such as those defined in
<a class="xref" href="../api/Gamelogic.Grids2.Algorithms.html">Algorithms</a> ). To do this, we need to let our grid implement the <a class="xref" href="../api/Gamelogic.Grids2.IGrid-2.html">IGrid&lt;TPoint, TCell&gt;</a>
interface. This ensures our
grid will have all the methods called by Algorithms. In this example, we will implement some irregular grid, with
neighbors defined on a special component that can be configured in the inspector:</p>
<pre><code class="lang-csharp">[Serializable]
public class Neighbors
{
    public int point;
    public List&lt;int&gt; neighbors;
}

[Serializable]
public class NeighborConfiguration : GLMonoBehaviour
{
    public List&lt;Neighbors&gt; neighbors;
}
</code></pre>
<h2 id="point-types">Point Types</h2>
<p>The first thing to do is choose a point type. You can use one of the existing point types, or define your own.
For this example, we will use <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a>, since it is
suitable for grids with either a 1D structure (such as the built-in <a class="xref" href="../api/Gamelogic.Grids2.Grid1-1.html">Grid1&lt;TCell&gt;</a> , or no important 2D
or 3D structure (for example, irregular grids).</p>
<h2 id="underlying-data-structure">Underlying Data Structure</h2>
<p>The second thing is to choose an underlying data structure to hold our cells. You can use a built-in grid for this, or
an array, or a dictionary, or any data structure that makes sense for your application. You may even choose to use
multiple data structures to optimize the various queries. In our case, we will use a dictionary. We will use the
<code>NeighborConfiguration</code> to make queries about neighbors.</p>
<pre><code class="lang-csharp">public class ExampleGrid&lt;TCell&gt; : IGrid&lt;int, TCell&gt;
{
    // Used in GetNeighbors function
    private static readonly int[] Empty = new int[] { };

    private Dictionary&lt;int, TCell&gt; cells;
    private Dictionary&lt;int, Neighbors&gt; neighbors;

    private NeighborConfiguration neighborConfiguration;

    public ExampleGrid(NeighborConfiguration neighborConfiguration)
    {
        this.neighborConfiguration = neighborConfiguration;

        cells = new Dictionary&lt;int, TCell&gt;();
        neighbors = new Dictionary&lt;int, Neighbors&gt;();

        foreach (var neighbor in neighborConfiguration.neighbors)
        {
            neighbors[neighbor.point] = neighbor.neighbors;
        }
    }
}
</code></pre>
<h2 id="implement-the-bounds-property">Implement the Bounds property</h2>
<p>You should use the right bounds type for your grid. For 1D, 2D, and 3D grids that use the standard grid points, you can
use one of the built-in types. For other grids, you need to use your own implementation of
@Gamelogic.Grids2.AbstractBounds .</p>
<h3 id="what-bounds-to-use">What bounds to use</h3>
<table>
<thead>
<tr>
<th>Grid Point Type</th>
<th>Bounds Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>GridInterval</td>
</tr>
<tr>
<td>GridPoint2</td>
<td>GridRect</td>
</tr>
<tr>
<td>GridPoint3</td>
<td>GridBounds</td>
</tr>
<tr>
<td>For any other type <code>T</code></td>
<td>A type that extends from @Gamelogic.Grids2.AbstractBound`1</td>
</tr>
</tbody>
</table>
<p>Since we are using <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a> as grid points, we use the <a class="xref" href="../api/Gamelogic.Grids2.GridInterval.html">GridInterval</a> class. For this example, we
will
implement the bounds
property to return a fixed interval.</p>
<pre><code class="lang-csharp">public class ExampleGrid&lt;TCell&gt; : IGrid&lt;int, TCell&gt;
{
    private readonly AbstractBounds&lt;int&gt; bounds = new GridInterval(0, 100);

    // Other members...

    public override AbstractBounds&lt;int&gt; Bounds
    {
        get { return bounds; }
    }
}
</code></pre>
<h2 id="implement-the-points-property">Implement the Points property</h2>
<p>This property should return all legal points for our grid. Don't think because we use a dictionary we only need to
return the dictionary keys. This would be valid in two cases: if we assigned empty slots to all valid keys in the
constructor, or if we wanted to implement a dynamic grid. We are not doing this here though.</p>
<p>Instead, we return all the points of our bounds interval:</p>
<pre><code class="lang-csharp">public override IEnumerable&lt;int&gt; Points
{
    get { return bounds.Points; }
}
</code></pre>
<h2 id="implement-the-cells-property">Implement the Cells property</h2>
<p>This method should return a cell for each point returned by the Points property.</p>
<pre><code class="lang-csharp">public IEnumerable&lt;TCell&gt; Cells
{
    get { return Points.Select(point =&gt; this[point]); }
}
</code></pre>
<h2 id="implement-the-item-property">Implement the Item property</h2>
<p>This property is what is used to get a single cell. It should always return a value for a point that falls within the
bounds. In this example, we check the point - if it is in the dictionary, we return the associated cell, otherwise, we
return the default value for the <code>TCell</code>.</p>
<pre><code class="lang-csharp">public override TCell this[int point]
{
    get
    {
        if (!bounds.Contains(point)) throw new Exception();
        if (!cells.ContainsKey(point)) return default(TCell);

        return cells[point];
    }
    
    set
    {
        if (!bounds.Contains(point)) throw new Exception();

        cells[point] = value;
    }
}
</code></pre>
<h2 id="implementing-the-contains-method">Implementing the Contains method</h2>
<p>This method tells whether the grid contains a given point. This does not mean the grid is initialized for that point
(that there is a valid cell at that point). This simply means the cell falls within the bounds of the grid. This method
determines the shape of the grid. It is sometimes limited by the underlying data structure (if we used a list, for
example, we would check whether the point falls inside the bounds of the list). In this case, we are not more limited
than our bounds allow, and so we can use that to implement this method. For more specific &quot;shapes&quot; you will have more
complicated logic.</p>
<pre><code class="lang-csharp">public override bool Contains(int point)
{
    return bounds.Contains(point);
}
</code></pre>
<h2 id="implement-the-getenumerator-methods">Implement the GetEnumerator methods</h2>
<p>These methods allow us to iterate over all point-cell pairs in the grid. The implementation is pretty straightforward:</p>
<pre><code class="lang-csharp">public IEnumerator&lt;PointCellPair&lt;int, TCell&gt;&gt; GetEnumerator()
{
    return Points.Select(
        point =&gt; new PointCellPair&lt;int, TCell&gt;(
            point,
            this[point])).GetEnumerator();
}
</code></pre>
<p>We also need a non-generic version, which is implemented by calling the method above:</p>
<pre><code class="lang-csharp">IEnumerator IEnumerable.GetEnumerator()
{
    return GetEnumerator();
}
</code></pre>
<h2 id="implement-clonestructure">Implement CloneStructure</h2>
<p>This method allows us to build a new grid with the same shape in a different type. We implement it by simply
constructing a grid with the same data.</p>
<pre><code class="lang-csharp">public override IGrid&lt;int, TNewCell&gt; CloneStructure&lt;TNewCell&gt;()
{
    return new ExampleGrid&lt;TNewCell&gt;(neighborConfiguration);
}
</code></pre>
<h2 id="customizations">Customizations</h2>
<p>Finally, you add whatever other methods you need. In this example, the whole point is to keep track of custom neighbors,
so we expose a method that can be used to get this information.</p>
<pre><code class="lang-csharp">public IEnumerable&lt;int&gt; GetNeighbors(int point)
{
    if (cells.ContainsKey(point))
    {
        return cells[point];
    }
    else
    {
        return Empty;
    }
}
</code></pre>
<p>When we use a method like the <a class="xref" href="../api/Gamelogic.Grids.Algorithms.html#Gamelogic_Grids_Algorithms_GetPointsInRange_">GetPointsInRange</a> method, we can use this <code>GetNeighbors</code>
method</p>
<pre><code class="lang-csharp">var path = Algorithms.GetPointsInRange(
    grid,
    0, 
    grid.GetNeighbors,
    p =&gt; true,
    (p, q) =&gt; 1,
    2);								
</code></pre>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
